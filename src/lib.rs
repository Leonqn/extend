//! Create extensions for types you don't own with [extension traits] but without the boilerplate.
//!
//! Example:
//!
//! ```rust
//! use extend::ext;
//!
//! #[ext]
//! impl<T: Ord> Vec<T> {
//!     fn sorted(mut self) -> Self {
//!         self.sort();
//!         self
//!     }
//! }
//!
//! fn main() {
//!     assert_eq!(
//!         vec![1, 2, 3],
//!         vec![2, 3, 1].sorted(),
//!     );
//! }
//! ```
//!
//! # How does it work?
//!
//! Under the hood it generates a trait with methods in your `impl` and implements those for the
//! type you specify. The code shown above expands roughly to:
//!
//! ```rust
//! trait VecExt<T: Ord> {
//!     fn sorted(self) -> Self;
//! }
//!
//! impl<T: Ord> VecExt<T> for Vec<T> {
//!     fn sorted(mut self) -> Self {
//!         self.sort();
//!         self
//!     }
//! }
//! ```
//!
//! # Configuration
//!
//! You can configure:
//!
//! - The visibility of the trait. The default visibility is private. Example: `#[ext(pub)]`. This
//! must be the first argument to the attribute
//! - The name of the generated extension trait. Example: `#[ext(name = MyExt)]`.
//! - Whether or not the generated trait should be [sealed]. Example: `#[ext(sealed = false)]`. The
//! default is `true`.
//!
//! [sealed]: https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed
//!
//! More examples:
//!
//! ```rust
//! use extend::ext;
//!
//! #[ext(name = SortedVecExt)]
//! impl<T: Ord> Vec<T> {
//!     fn sorted(mut self) -> Self {
//!         self.sort();
//!         self
//!     }
//! }
//!
//! #[ext(pub(crate))]
//! impl i32 {
//!     fn double(self) -> i32 {
//!         self * 2
//!     }
//! }
//!
//! #[ext(pub, name = ResultSafeUnwrapExt)]
//! impl<T> Result<T, std::convert::Infallible> {
//!     fn safe_unwrap(self) -> T {
//!         match self {
//!             Ok(t) => t,
//!             Err(_) => unreachable!(),
//!         }
//!     }
//! }
//! ```
//!
//! [extension traits]: https://dev.to/matsimitsu/extending-existing-functionality-in-rust-with-traits-in-rust-3622

#![doc(html_root_url = "https://docs.rs/extend/0.0.2")]

extern crate proc_macro;

use proc_macro_error::*;
use quote::{format_ident, quote, IdentFragment};
use std::fmt;
use syn::{
    parse::{self, Parse, ParseStream},
    parse_macro_input,
    spanned::Spanned,
    token::Semi,
    Ident, ImplItem, ItemImpl, LitBool, Token, TraitItemMethod, Type, Visibility,
};

/// See crate docs for more info.
#[proc_macro_attribute]
#[proc_macro_error]
#[allow(clippy::unneeded_field_pattern)]
pub fn ext(
    attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    let item = parse_macro_input!(item as ItemImpl);
    let config = parse_macro_input!(attr as Config);

    let ItemImpl {
        attrs,
        unsafety,
        generics,
        trait_,
        self_ty,
        items,
        // What is defaultness?
        defaultness: _,
        impl_token: _,
        brace_token: _,
    } = item;

    if let Some((_, path, _)) = trait_ {
        abort!(path.span(), "Trait impls cannot be used for #[ext]");
    }

    let ext_trait_name = config
        .ext_trait_name
        .unwrap_or_else(|| ext_trait_name(&*self_ty));

    let trait_methods = items
        .iter()
        .map(|item| trait_method(item))
        .collect::<Vec<_>>();

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let private_mod_name = format_ident!("private_{}", ext_trait_name);

    let visibility = &config.visibility;

    let (sealed_mod, sealed_super_trait) = if config.sealed {
        (
            quote! {
                #[allow(non_snake_case)]
                /// Generated by `#[ext]`.
                ///
                /// Contains stuff required to make the extension trait sailed.
                mod #private_mod_name {
                    use super::*;

                    pub trait Sealed {}

                    impl #impl_generics Sealed for #self_ty #where_clause {}
                }
            },
            quote! {
                : #private_mod_name::Sealed
            },
        )
    } else {
        (quote! {}, quote! {})
    };

    let code = (quote! {
        #[allow(non_camel_case_types)]
        #(#attrs)*
        #visibility
        #unsafety
        trait #ext_trait_name #impl_generics #sealed_super_trait #where_clause {
            #(
                #[allow(
                    patterns_in_fns_without_body,
                    clippy::inline_fn_without_body,
                    unused_attributes
                )]
                #trait_methods
            )*
        }

        impl #impl_generics #ext_trait_name #ty_generics for #self_ty #where_clause {
            #(#items)*
        }

        #sealed_mod
    })
    .into();
    // eprintln!("{}", code);
    code
}

fn ext_trait_name(self_ty: &Type) -> Ident {
    fn inner_self_ty(self_ty: &Type) -> Either<Ident, &Ident> {
        match self_ty {
            Type::Path(inner) => Either::B(
                &inner
                    .path
                    .segments
                    .last()
                    .unwrap_or_else(|| abort!(inner.span(), "Empty type path"))
                    .ident,
            ),
            Type::Reference(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("Ref{}", name))
            }
            Type::Array(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("ListOf{}", name))
            }
            Type::Group(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("Group{}", name))
            }
            Type::Paren(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("Paren{}", name))
            }
            Type::Ptr(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("PointerTo{}", name))
            }
            Type::Slice(inner) => {
                let name = inner_self_ty(&inner.elem);
                Either::A(format_ident!("SliceOf{}", name))
            }
            Type::Tuple(inner) => {
                let mut name = format_ident!("TupleOf");
                for elem in &inner.elems {
                    name = format_ident!("{}{}", name, inner_self_ty(elem));
                }
                Either::A(name)
            }
            Type::BareFn(_)
            | Type::ImplTrait(_)
            | Type::Infer(_)
            | Type::Macro(_)
            | Type::Never(_)
            | Type::Verbatim(_)
            | Type::TraitObject(_)
            | _ => abort!(
                self_ty.span(),
                "#[ext] is not supported for this kind of type"
            ),
        }
    }

    format_ident!("{}Ext", inner_self_ty(self_ty))
}

enum Either<A, B> {
    A(A),
    B(B),
}

impl<A: IdentFragment, B: IdentFragment> quote::IdentFragment for Either<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Either::A(x) => x.fmt(f),
            Either::B(x) => x.fmt(f),
        }
    }
}

impl<A: Spanned, B: Spanned> Spanned for Either<A, B> {
    fn span(&self) -> proc_macro2::Span {
        match self {
            Either::A(x) => x.span(),
            Either::B(x) => x.span(),
        }
    }
}

fn trait_method(item: &ImplItem) -> TraitItemMethod {
    let method = match item {
        ImplItem::Method(method) => method,
        _ => abort!(item.span(), "Only methods are allowed in #[ext] impls"),
    };

    TraitItemMethod {
        attrs: method.attrs.clone(),
        sig: method.sig.clone(),
        default: None,
        semi_token: Some(Semi::default()),
    }
}

#[derive(Debug)]
struct Config {
    ext_trait_name: Option<Ident>,
    visibility: Visibility,
    sealed: bool,
}

impl Parse for Config {
    fn parse(input: ParseStream) -> parse::Result<Self> {
        let mut config = Config::default();

        if let Ok(visibility) = input.parse::<Visibility>() {
            config.visibility = visibility;
        }

        input.parse::<Token![,]>().ok();

        while !input.is_empty() {
            let ident = input.parse::<Ident>()?;
            input.parse::<Token![=]>()?;

            match &*ident.to_string() {
                "name" => {
                    config.ext_trait_name = Some(input.parse()?);
                }
                "sealed" => {
                    config.sealed = input.parse::<LitBool>()?.value;
                }
                _ => abort!(ident.span(), "Unknown configuration name"),
            }

            input.parse::<Token![,]>().ok();
        }

        Ok(config)
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            ext_trait_name: None,
            visibility: Visibility::Inherited,
            sealed: true,
        }
    }
}

#[cfg(test)]
mod test {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    fn test_ui() {
        let t = trybuild::TestCases::new();
        t.pass("tests/compile_pass/*.rs");
        t.compile_fail("tests/compile_fail/*.rs");
    }
}
